import requests
import re
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import webbrowser
import tkinter as tk
from tkinter import messagebox, scrolledtext

class VulnerabilityScannerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Website Vulnerability Scanner")

        self.url_label = tk.Label(root, text="Enter the URL to scan:")
        self.url_label.pack()

        self.url_entry = tk.Entry(root, width=50)
        self.url_entry.pack()

        self.scan_button = tk.Button(root, text="Scan", command=self.scan_website)
        self.scan_button.pack()

        self.output_text = scrolledtext.ScrolledText(root, width=100, height=30)
        self.output_text.pack()

    def scan_website(self):
        url = self.url_entry.get()
        if not url:
            messagebox.showerror("Error", "Please enter a URL")
            return

        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, f"Scanning {url}...\n\n")

        discovered_urls = self.discover_urls(url)
        self.output_text.insert(tk.END, f"Discovered {len(discovered_urls)} URLs on {url}:\n")
        for i, discovered_url in enumerate(discovered_urls, start=1):
            self.output_text.insert(tk.END, f"{i}. {discovered_url}\n")

        for page_url in discovered_urls:
            vulnerabilities = self.scan_url(page_url)
            if vulnerabilities:
                self.output_text.insert(tk.END, f"\nVulnerabilities found on {page_url}:\n")
                for vulnerability, attack_method in vulnerabilities.items():
                    self.output_text.insert(tk.END, f"\nVulnerability: {vulnerability}\n")
                    self.output_text.insert(tk.END, f"Attack Method: {attack_method}\n")
                    if vulnerability == "SQL injection vulnerability":
                        self.output_text.insert(tk.END, "\nSQL Injection Method:\n")
                        self.output_text.insert(tk.END, "1. Identify the input field vulnerable to SQL injection\n")
                        self.output_text.insert(tk.END, "2. Inject SQL code to manipulate the query, e.g., ' OR '1'='1'\n")
                        self.output_text.insert(tk.END, "3. Observe the response for any error messages or unusual behavior\n")
                        self.exploit_sql_injection(page_url)

                    if vulnerability == "Cross-site scripting (XSS) vulnerability":
                        self.output_text.insert(tk.END, "\nXSS Attack Method:\n")
                        self.output_text.insert(tk.END, "1. Identify the input field vulnerable to XSS\n")
                        self.output_text.insert(tk.END, "2. Inject malicious scripts, e.g., <script>alert('XSS')</script>\n")
                        self.output_text.insert(tk.END, "3. Observe the behavior of the injected script\n")
                        self.exploit_xss_vulnerability(page_url)

    def discover_urls(self, url):
        discovered_urls = []
        try:
            response = requests.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, "html.parser")
            for anchor_tag in soup.find_all("a"):
                href = anchor_tag.get("href")
                if href:
                    absolute_url = urljoin(url, href)
                    if absolute_url.startswith(url):
                        discovered_urls.append(absolute_url)
        except requests.RequestException as e:
            self.output_text.insert(tk.END, f"Error discovering URLs on {url}: {e}\n")
        return discovered_urls

    def scan_url(self, url):
        vulnerabilities = {}
        if self.is_sql_injection_vulnerable(url):
            vulnerabilities["SQL injection vulnerability"] = "Injecting SQL code into input fields"
        if self.is_xss_vulnerable(url):
            vulnerabilities["Cross-site scripting (XSS) vulnerability"] = "Injecting malicious scripts into input fields"
        if self.has_insecure_configuration(url):
            vulnerabilities["Insecure server configuration"] = "Exploiting insecure communication protocols"
        return vulnerabilities

    def is_sql_injection_vulnerable(self, url):
        try:
            payload = "' OR '1'='1"
            response = requests.get(f"{url}?id={payload}")
            if re.search(r"error|warning", response.text, re.IGNORECASE):
                return True
        except requests.RequestException:
            return False
        return False

    def is_xss_vulnerable(self, url):
        try:
            payload = "<script>alert('XSS')</script>"
            response = requests.get(f"{url}?input={payload}")
            if payload in response.text:
                return True
        except requests.RequestException:
            return False
        return False

    def has_insecure_configuration(self, url):
        return not url.startswith("https")

    def exploit_sql_injection(self, url):
        webbrowser.open(url)

    def exploit_xss_vulnerability(self, url):
        webbrowser.open(url)

if __name__ == "__main__":
    root = tk.Tk()
    app = VulnerabilityScannerApp(root)
    root.mainloop()
